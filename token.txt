import time
import hashlib
import requests
import json
import random
import string
import re
import logging
import asyncio
from telethon import TelegramClient, events

# تنظیم لاگ
logging.basicConfig(filename='bot.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# اطلاعات API صرافی
API_KEY = '020aaf413124276177c5a9cf1901688f'  # جای خالی را با کلید خود پر کنید
API_SECRET = 'fdda20fc1abad96ac42311f6231930fb'  # جای خالی را با کلید خود پر کنید
BASE_URL = 'https://fapi.bitunix.com'

# اطلاعات API تلگرام
api_id = '25337283'
api_hash = '9a40009bc193b42f209a0ac417e63d6d'
client = TelegramClient('session_name', api_id, api_hash)

# توابع کمکی صرافی
def get_nonce():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=32))

def sha256_hex(input_string):
    return hashlib.sha256(input_string.encode('utf-8')).hexdigest()

def get_signature(api_key, secret_key, nonce, timestamp, query_string, body):
    digest_input = nonce + timestamp + api_key + query_string + body
    digest = sha256_hex(digest_input)
    final_sign = sha256_hex(digest + secret_key)
    return final_sign

def get_price(symbol):
    try:
        url = f"{BASE_URL}/api/v1/futures/market/funding_rate?symbol={symbol}"
        response = requests.get(url)
        data = response.json()
        if data.get("code") == 0:
            return float(data["data"]["lastPrice"])
        else:
            logging.error(f"Failed to get price: {data}")
            return None
    except Exception as e:
        logging.error(f"Error getting price for {symbol}: {e}")
        return None

def set_leverage(symbol, leverage):
    try:
        url = f"{BASE_URL}/api/v1/futures/account/change_leverage"
        nonce = get_nonce()
        timestamp = str(int(time.time() * 1000))
        query_string = ""
        body_dict = {
            "symbol": symbol,
            "leverage": leverage
        }
        body_json = json.dumps(body_dict, separators=(',', ':'))
        sign = get_signature(API_KEY, API_SECRET, nonce, timestamp, query_string, body_json)
        headers = {
            "api-key": API_KEY,
            "sign": sign,
            "nonce": nonce,
            "timestamp": timestamp,
            "Content-Type": "application/json",
            "language": "en-US"
        }
        response = requests.post(url, headers=headers, data=body_json)
        response_data = response.json()
        if response_data.get("code") == 0:
            logging.info(f"Leverage set to {leverage} for {symbol}: {response_data}")
        else:
            logging.error(f"Failed to set leverage: {response_data}")
    except Exception as e:
        logging.error(f"Error setting leverage for {symbol}: {e}")

def place_order(signal):
    try:
        symbol = signal["symbol"] + "USDT"  # فرمت نماد (مثل SUIUSDT)
        side = "BUY" if signal["type"] == "LONG" else "SELL"
        entry_price = signal["entry_price"]
        tp_price = signal["tp_price"]
        sl_price = signal["sl_price"]
        leverage = 20  # قابل تنظیم بر اساس استراتژی
        usdt_amount = 0.5  # مقدار ثابت USDT برای سفارش (قابل تنظیم)

        # گرفتن قیمت بازار برای محاسبه qty
        market_price = get_price(symbol)
        if not market_price:
            logging.error(f"Cannot place order: Failed to get market price for {symbol}")
            return

        # محاسبه مقدار سفارش (qty)
        qty = round((usdt_amount / market_price) * leverage, 6)

        # تنظیم لوریج
        set_leverage(symbol, leverage)

        # ثبت سفارش
        url = f"{BASE_URL}/api/v1/futures/trade/place_order"
        nonce = get_nonce()
        timestamp = str(int(time.time() * 1000))
        query_string = ""
        body_dict = {
            "symbol": symbol,
            "leverage": leverage,
            "marginCoin": "USDT",
            "side": side,
            "price": str(entry_price),
            "tradeSide": "OPEN",
            "effect": "GTC",
            "orderType": "LIMIT",
            "qty": str(qty),
            "tpPrice": str(tp_price),
            "tpStopType": "MARK",
            "tpOrderType": "LIMIT",
            "tpOrderPrice": str(tp_price),
            "slPrice": str(sl_price),
            "slStopType": "MARK",
            "slOrderType": "LIMIT",
            "slOrderPrice": str(sl_price)
        }
        body_json = json.dumps(body_dict, separators=(',', ':'))
        sign = get_signature(API_KEY, API_SECRET, nonce, timestamp, query_string, body_json)
        headers = {
            "api-key": API_KEY,
            "sign": sign,
            "nonce": nonce,
            "timestamp": timestamp,
            "Content-Type": "application/json",
            "language": "en-US"
        }
        response = requests.post(url, headers=headers, data=body_json)
        response_data = response.json()
        if response_data.get("code") == 0:
            logging.info(f"Order placed successfully for {symbol}: {response_data}")
        else:
            logging.error(f"Failed to place order for {symbol}: {response_data}")
    except Exception as e:
        logging.error(f"Error placing order for {symbol}: {e}")

# توابع مربوط به تلگرام
def clean_number(text):
    if not text:
        return None
    text = text.replace(",", "")
    try:
        return float(text)
    except ValueError:
        return None

def parse_signal(text):
    if "Futures (Free Signal)" not in text:
        return None
    
    signal = {}
    try:
        logging.info(f"Raw signal text: {text}")
        
        type_match = re.search(r"(SHORT|LONG)", text, re.IGNORECASE)
        signal["type"] = type_match.group(1).upper() if type_match else None
        
        symbol_match = re.search(r"#(\w+/?USDT)", text, re.IGNORECASE)
        signal["symbol"] = symbol_match.group(1).replace("/USDT", "") if symbol_match else None
        
        entry_zone = re.search(r"Entry zone\s*[:|-]\s*[\d.]+\s*[-|]\s*([\d.]+)", text, re.IGNORECASE)
        signal["entry_price"] = clean_number(entry_zone.group(1)) if entry_zone else None
        
        targets = re.findall(r"Targets\s*[:|-].*?\n\s*([\d.]+)\s*[-|]?\s*\n\s*([\d.]+)?", text, re.DOTALL | re.IGNORECASE)
        signal["tp_price"] = clean_number(targets[0][1]) if targets and len(targets[0]) > 1 and targets[0][1] else None
        
        sl_match = re.search(r"Stop loss\s*[:|-]\s*([\d.]+)", text, re.IGNORECASE)
        signal["sl_price"] = clean_number(sl_match.group(1)) if sl_match else None
        
        return signal
    except Exception as e:
        logging.error(f"Error parsing signal: {e}")
        return None

@client.on(events.NewMessage(chats='@SHAHROKH_COIN'))
async def handle_new_signal(event):
    signal = parse_signal(event.message.text)
    if signal and all([signal["type"], signal["symbol"], signal["entry_price"], signal["tp_price"], signal["sl_price"]]):
        logging.info(f"New signal detected: {signal}")
        place_order(signal)  # ثبت سفارش با سیگنال
    else:
        missing = [key for key, value in signal.items() if value is None] if signal else ["all"]
        logging.warning(f"Invalid or incomplete signal. Missing: {missing}")

async def main():
    await client.start()
    logging.info("Bot is running and monitoring @SHAHROKH_COIN...")
    while True:
        if not client.is_connected():
            logging.warning("Reconnecting to Telegram...")
            await client.connect()
        await asyncio.sleep(60)
    await client.run_until_disconnected()

if __name__ == "__main__":
    try:
        with client:
            client.loop.run_until_complete(main())
    except Exception as e:
        logging.error(f"Bot error: {e}")